# ADR-0001: Monorepo Architecture with AI Code Generator

## Status
Accepted

## Date
2024-01-01

## Context

We need to build a production-ready full-stack application that:
- Supports multiple applications (web, API, BFF)
- Shares code and types across applications
- Provides consistent development experience
- Enables AI-assisted code generation
- Scales with the team and codebase

## Decision

We will implement a monorepo architecture using:

### Monorepo Management
- **Turborepo**: Build system with caching and task orchestration
- **pnpm**: Fast, disk-efficient package manager with workspace support
- **TypeScript**: Type safety across the entire codebase

### Application Stack

#### Frontend (apps/web)
- **Next.js 15**: React framework with App Router
- **Server Components**: Default rendering strategy
- **TailwindCSS**: Utility-first styling
- **Auth.js (NextAuth)**: Authentication with GitHub provider

#### Backend API (apps/api)
- **NestJS**: Progressive Node.js framework
- **Prisma**: Type-safe ORM
- **PostgreSQL**: Relational database
- **OpenAPI 3.1**: API documentation with Swagger

#### BFF (apps/bff)
- **NestJS**: Backend-for-frontend layer
- **Purpose**: Aggregate and transform API responses for web consumption

### Shared Packages
- **@monorepo/shared-types**: Common TypeScript interfaces and types
- **@monorepo/config**: Shared configuration (ESLint, TypeScript, etc.)
- **@monorepo/ui**: Reusable React components

### Infrastructure
- **Docker**: Containerization for all services
- **Docker Compose**: Local development environment
- **GitHub Actions**: CI/CD pipeline

### AI Code Generator (agent/)
- **Commander.js**: CLI framework
- **ts-morph**: TypeScript AST manipulation
- **YAML**: Specification format
- **Features**:
  - Idempotent code generation
  - Dry-run mode
  - Template-based scaffolding

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────┐
│                     Monorepo Root                        │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐        │
│  │  apps/web  │  │  apps/api  │  │  apps/bff  │        │
│  │            │  │            │  │            │        │
│  │  Next.js   │  │  NestJS    │  │  NestJS    │        │
│  │  + Auth    │  │  + Prisma  │  │            │        │
│  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘        │
│        │               │               │                │
│        └───────────────┴───────────────┘                │
│                        │                                │
│        ┌───────────────┴────────────────┐               │
│        │                                │               │
│  ┌─────▼─────────┐  ┌─────────────┐  ┌─▼──────────┐   │
│  │ shared-types  │  │   config    │  │     ui     │   │
│  │   (package)   │  │  (package)  │  │  (package) │   │
│  └───────────────┘  └─────────────┘  └────────────┘   │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │              agent/ (Code Generator)            │    │
│  │  CLI → Specs → Templates → Generated Code       │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

## Consequences

### Positive
- **Code Sharing**: TypeScript types, utilities, and components are shared
- **Type Safety**: End-to-end type checking from DB to UI
- **Developer Experience**: Single repo, unified tooling
- **Scalability**: Easy to add new apps and packages
- **AI Assistance**: Code generation reduces boilerplate
- **Consistency**: Shared configs ensure consistent code style

### Negative
- **Complexity**: Initial setup is more complex
- **Build Times**: Full builds can be slow without caching
- **Learning Curve**: Team needs to understand monorepo concepts
- **Coordination**: Changes affecting multiple packages require care

### Mitigations
- **Turborepo Caching**: Speeds up builds significantly
- **Documentation**: Comprehensive guides for new developers
- **Incremental Adoption**: Can add apps/packages gradually
- **CI/CD**: Automated testing ensures changes don't break dependencies

## Implementation Details

### Package Dependencies
```json
{
  "@monorepo/web": {
    "dependencies": ["@monorepo/ui", "@monorepo/shared-types"]
  },
  "@monorepo/api": {
    "dependencies": ["@monorepo/shared-types"]
  },
  "@monorepo/bff": {
    "dependencies": ["@monorepo/shared-types"]
  }
}
```

### Build Order
1. `@monorepo/shared-types`
2. `@monorepo/config`
3. `@monorepo/ui`
4. `@monorepo/api`, `@monorepo/bff`, `@monorepo/web` (parallel)

### Development Workflow
1. Make changes to code
2. Turborepo rebuilds affected packages
3. Hot reload in dev servers
4. Run tests before committing
5. CI validates on push

## Alternatives Considered

### 1. Polyrepo (Multiple Repositories)
**Rejected**: Too much overhead managing versions and dependencies across repos

### 2. Lerna + Yarn Workspaces
**Rejected**: pnpm is faster and more efficient; Turborepo has better caching

### 3. Rush
**Rejected**: Turborepo has better DX and simpler configuration

### 4. No Code Generator
**Rejected**: Reduces productivity; AI assistance is a key differentiator

## References

- [Turborepo Documentation](https://turbo.build/repo)
- [pnpm Workspaces](https://pnpm.io/workspaces)
- [NestJS Best Practices](https://docs.nestjs.com/)
- [Next.js App Router](https://nextjs.org/docs/app)
- [Prisma Best Practices](https://www.prisma.io/docs/guides/performance-and-optimization)
