import { AppSpec, Entity } from '../schema/app-spec';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { render } from 'ejs';
import { readFileSync } from 'fs';

export interface GeneratorOptions {
  dryRun: boolean;
  outputDir: string;
}

export class Generator {
  private options: GeneratorOptions;
  private changes: Array<{ path: string; content: string }> = [];

  constructor(options: GeneratorOptions) {
    this.options = options;
  }

  async generate(spec: AppSpec): Promise<void> {
    console.log(`\nGenerating application: ${spec.name}`);
    console.log(`Entities: ${spec.entities.length}`);
    
    // Generate Prisma schema
    await this.generatePrismaSchema(spec.entities);
    
    // Generate NestJS modules for each entity
    for (const entity of spec.entities) {
      await this.generateNestJSModule(entity);
    }
    
    // Generate Next.js pages if specified
    if (spec.pages) {
      for (const page of spec.pages) {
        await this.generateNextJSPage(page, spec);
      }
    }
    
    // Write changes
    if (!this.options.dryRun) {
      this.writeChanges();
    } else {
      console.log('\nDry run - Changes preview:');
      this.changes.forEach(({ path }) => {
        console.log(`  - ${path}`);
      });
    }
  }

  private async generatePrismaSchema(entities: Entity[]): Promise<void> {
    const template = `
// Generated by agent - DO NOT EDIT MANUALLY
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

<% entities.forEach(entity => { %>
model <%= entity.name %> {
  id        String   @id @default(uuid())
<% entity.fields.forEach(field => { %>
<% if (field.type !== 'relation') { %>
  <%= field.name %> <%= getPrismaType(field.type) %><%= field.required ? '' : '?' %>
<% } %>
<% }); %>
<% if (entity.timestamps) { %>
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
<% } %>

  @@map("<%= entity.name.toLowerCase() %>s")
}
<% }); %>
`;

    const content = render(template, {
      entities,
      getPrismaType: (type: string) => {
        const typeMap: Record<string, string> = {
          string: 'String',
          number: 'Int',
          boolean: 'Boolean',
          date: 'DateTime',
          uuid: 'String',
        };
        return typeMap[type] || 'String';
      },
    });

    this.addChange('apps/api/prisma/schema.prisma', content);
  }

  private async generateNestJSModule(entity: Entity): Promise<void> {
    const entityName = entity.name.toLowerCase();
    const modulePath = `apps/api/src/${entityName}`;
    
    // DTO
    const dtoContent = this.generateDTO(entity);
    this.addChange(`${modulePath}/${entityName}.dto.ts`, dtoContent);
    
    // Service
    const serviceContent = this.generateService(entity);
    this.addChange(`${modulePath}/${entityName}.service.ts`, serviceContent);
    
    // Controller
    const controllerContent = this.generateController(entity);
    this.addChange(`${modulePath}/${entityName}.controller.ts`, controllerContent);
    
    // Module
    const moduleContent = this.generateModule(entity);
    this.addChange(`${modulePath}/${entityName}.module.ts`, moduleContent);
  }

  private generateDTO(entity: Entity): string {
    return `import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsBoolean, IsOptional } from 'class-validator';

export class Create${entity.name}Dto {
${entity.fields.map(field => {
  if (field.type === 'relation') return '';
  return `  @ApiProperty()
  @Is${field.type === 'string' ? 'String' : field.type === 'boolean' ? 'Boolean' : 'String'}()
  ${!field.required ? '@IsOptional()' : ''}
  ${field.name}${!field.required ? '?' : ''}: ${field.type === 'string' ? 'string' : field.type === 'boolean' ? 'boolean' : field.type === 'number' ? 'number' : 'string'};
`;
}).join('\n')}
}

export class Update${entity.name}Dto extends Create${entity.name}Dto {}
`;
  }

  private generateService(entity: Entity): string {
    const entityName = entity.name;
    const entityLower = entityName.toLowerCase();
    
    return `import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Create${entityName}Dto, Update${entityName}Dto } from './${entityLower}.dto';

@Injectable()
export class ${entityName}Service {
  constructor(private prisma: PrismaService) {}

  async findAll() {
    return this.prisma.${entityLower}.findMany();
  }

  async findOne(id: string) {
    const item = await this.prisma.${entityLower}.findUnique({ where: { id } });
    if (!item) throw new NotFoundException();
    return item;
  }

  async create(data: Create${entityName}Dto) {
    return this.prisma.${entityLower}.create({ data });
  }

  async update(id: string, data: Update${entityName}Dto) {
    await this.findOne(id);
    return this.prisma.${entityLower}.update({ where: { id }, data });
  }

  async remove(id: string) {
    await this.findOne(id);
    await this.prisma.${entityLower}.delete({ where: { id } });
  }
}
`;
  }

  private generateController(entity: Entity): string {
    const entityName = entity.name;
    const entityLower = entityName.toLowerCase();
    
    return `import { Controller, Get, Post, Put, Delete, Body, Param } from '@nestjs/common';
import { ApiTags, ApiOperation } from '@nestjs/swagger';
import { ${entityName}Service } from './${entityLower}.service';
import { Create${entityName}Dto, Update${entityName}Dto } from './${entityLower}.dto';

@ApiTags('${entityLower}')
@Controller('${entityLower}')
export class ${entityName}Controller {
  constructor(private readonly service: ${entityName}Service) {}

  @Get()
  @ApiOperation({ summary: 'Get all ${entityLower}s' })
  findAll() {
    return this.service.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a ${entityLower} by id' })
  findOne(@Param('id') id: string) {
    return this.service.findOne(id);
  }

  @Post()
  @ApiOperation({ summary: 'Create a new ${entityLower}' })
  create(@Body() dto: Create${entityName}Dto) {
    return this.service.create(dto);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update a ${entityLower}' })
  update(@Param('id') id: string, @Body() dto: Update${entityName}Dto) {
    return this.service.update(id, dto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a ${entityLower}' })
  remove(@Param('id') id: string) {
    return this.service.remove(id);
  }
}
`;
  }

  private generateModule(entity: Entity): string {
    const entityName = entity.name;
    const entityLower = entityName.toLowerCase();
    
    return `import { Module } from '@nestjs/common';
import { ${entityName}Controller } from './${entityLower}.controller';
import { ${entityName}Service } from './${entityLower}.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [${entityName}Controller],
  providers: [${entityName}Service],
})
export class ${entityName}Module {}
`;
  }

  private async generateNextJSPage(page: any, spec: AppSpec): Promise<void> {
    // Simplified page generation
    const content = `export default function ${page.name}Page() {
  return (
    <div className="container mx-auto p-8">
      <h1 className="text-3xl font-bold">${page.name}</h1>
      <p>Generated page for ${page.route}</p>
    </div>
  );
}
`;
    
    this.addChange(`apps/web/src/app${page.route}/page.tsx`, content);
  }

  private addChange(path: string, content: string): void {
    this.changes.push({ path, content });
  }

  private writeChanges(): void {
    for (const { path, content } of this.changes) {
      const fullPath = join(this.options.outputDir, path);
      const dir = join(...fullPath.split('/').slice(0, -1));
      
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
      
      writeFileSync(fullPath, content, 'utf-8');
      console.log(`  âœ“ ${path}`);
    }
  }
}
